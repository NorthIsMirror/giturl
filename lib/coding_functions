# FUNCTION: process_meta_data {{{
# $1 - bits decoded from zcode
# $REPLY = bits to skip
# $reply = ( file "" rev "" repo "" wordrev "" chksum "" site_flags "" unused1 "" unused3 "" error "" )
process_meta_data() {
    local -a bits
    bits=( "$@" )
    integer size="$#"

    bits=( "${(Oa)bits[@]}" )
    local strbits="${(j::)bits}"
    integer init_len="${#strbits}"

    local -A decoded
    decoded=(
        file ""
        rev ""
        repo ""
        wordrev ""
        chksum ""
        site_flags ""
        unused1 ""
        unused3 ""
        error ""
    )

    # Is there SS?
    if [ "${strbits[1,${#codes[ss]}]}" = "${codes[ss]}" ]; then
        strbits="${strbits[${#codes[ss]}+1,-1]}"
        # Is there immediate following SS?
        if [ "${strbits[1,${#codes[ss]}]}" = "${codes[ss]}" ]; then
            # We should skip one SS and there is nothing to decode
            REPLY="${#codes[ss]}"
            reply=( file "" rev "" repo "" wordrev "" chksum "" site_flags "" unused1 "" unused3 "" error "" )
            return 0
        fi

        #
        # Follows meta data, decode it
        #

        # keys of the 'decoded' hash
        local current_selector="error"
        integer trylen
        local mat trystr
        while (( 1 )); do
            mat=""
            for (( trylen=1; trylen <= 7; trylen ++ )); do
                # Take substring of len $trylen and check if
                # it matches any Huffman code
                trystr="${strbits[1,trylen]}"
                mat="${rcodes[$trystr]}"
                [ -n "$mat" ] && break
            done

            # General failure in decoding the string
            if [ -z "$mat" ]; then
                REPLY="-1"
                reply=( file "" rev "" repo "" wordrev "" chksum "" site_flags "" unused1 "" unused3 "" error "" )
                return 1
            fi

            # Skip decoded bits
            strbits="${strbits[trylen+1,-1]}"

            # Handle what has been matched, either selector or data
            case "$mat" in
                (ss)
                    break
                    ;;
                (file|rev|repo|wordrev|chksum|site_flags)
                    current_selector="$mat"
                    ;;
                (unused2|unused3)
                    current_selector="$mat"
                    ;;
                (*)
                    [[ "$current_selector" = "site_flags" ]] && {
                        mat="${rsites[$mat]}"
                        decoded[$current_selector]+="$mat,"
                    } || {
                        decoded[$current_selector]+="$mat"
                    }
                    ;;
            esac
        done

        REPLY="$(( init_len - ${#strbits} ))"
        reply=( "${(kv)decoded[@]}" )
    else
        # No meta data and no special ending of zekyll bits
        REPLY="0"
        reply=( file "" rev "" repo "" wordrev "" chksum "" site_flags "" unused1 "" unused3 "" error "" )
    fi

    return 0
}
# }}}
# FUNCTION: get_code_data {{{
#
# Gets meta data: rev, file, repo and puts it into $reply array
# REPLY has the revision bits
get_code_data() {
    local zcode="$1"
    decode_zcode "$zcode"

    local -a bits
    bits=( "${reply[@]}" )

    process_meta_data "${bits[@]}"
    # $reply contains: ( file "" rev "" repo "" wordrev "" chksum "" site_flags "" unused1 "" unused3 "" error "" )
    # $REPLY contains: number of final bits that contained the meta data
    local -a meta_reply
    meta_reply=( "${reply[@]}" )

    # Skip bits that were processed as meta data
    bits=( "${(@)bits[1,-1*REPLY-1]}" )

    # Two last bits here are version
    version=( "${(@)bits[-2,-1]}" )
    bits[-1]=()
    bits[-1]=()

    integer size="${#bits}"

    REPLY="${bits[*]}"
    reply=( "${meta_reply[@]}" )
}
# }}}
# FUNCTION: bits_start {{{
bits_start() {
    reply=( "${(@s::)codes[ss]}" )
}
# }}}
# FUNCTION: bits_stop {{{
bits_stop() {
    reply=( "${(@s::)codes[ss]}" )
}
# }}}
# FUNCTION: bits_rev {{{
bits_rev() {
    local -a bits
    local rev="$1"

    for lt in "${(@s::)rev}"; do
        if [ -n "${codes[$lt]}" ];then
            bits+=( "${(@s::)codes[$lt]}" )
        elif [ -n "$lt" ]; then
            SetMessage "Incorrect character in rev name: '$lt', trying to continue"
        fi
    done

    # Rev preamble
    if [[ "${#bits}" -gt "0" ]]; then
        bits=( "${(@s::)codes[rev]}" "${bits[@]}" )
    fi

    reply=( "${bits[@]}" )
    return 0
}
# }}}
# FUNCTION: bits_file {{{
bits_file() {
    local -a bits
    local file="$1"

    for lt in "${(@s::)file}"; do
        if [ -n "${codes[$lt]}" ];then
            bits+=( "${(@s::)codes[$lt]}" )
        elif [ -n "$lt" ]; then
            SetMessage "Incorrect character in file name: '$lt', trying to continue"
        fi
    done

    # File preamble
    if [[ "${#bits}" -gt "0" ]]; then
        bits=( "${(@s::)codes[file]}" "${bits[@]}" )
    fi

    reply=( "${bits[@]}" )
    return 0
}
# }}}
# FUNCTION: bits_repo {{{
bits_repo() {
    local -a bits
    local repo="$1"

    for lt in "${(@s::)repo}"; do
        if [ -n "${codes[$lt]}" ]; then
            bits+=( "${(@s::)codes[$lt]}" )
        elif [ -n "$lt" ]; then
            SetMessage "Incorrect character in repo name: '$lt', trying to continue"
        fi
    done

    # Repo preamble
    if [[ "${#bits}" -gt "0" ]]; then
        bits=( "${(@s::)codes[repo]}" "${bits[@]}" )
    fi

    reply=( "${bits[@]}" )
    return 0
}
# }}}
# FUNCTION: bits_site {{{
bits_site() {
    local -a bits
    local site="$1"

    reply=()

    # Github is the default site
    [ "$site" = "gh" ] && return

    local site_lt="${sites[$1]}"
    [ -z "$site_lt" ] && return

    bits+=( "${(@s::)codes[$site_lt]}" )

    # Site preamble
    bits=( "${(@s::)codes[site]}" "${bits[@]}" )

    reply=( "${bits[@]}" )
    return 0
}
# }}}

# vim:ft=zsh
