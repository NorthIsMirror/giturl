setopt typesetsilent

local -a characters
characters=( 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

# Latin-1 Supplement [µºÀ-ÖØ-áãäæ-öøú-ÿ]
µ º À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï Ð Ñ Ò Ó Ô Õ Ö Ø Ù Ú Û Ü Ý Þ ß à á ã ä æ ç è é ê ë ì í î ï ð ñ ò ó ô õ ö ø ú û ü ý þ ÿ

# Latin Extended-A [ÿ-ſ]
Ā ā Ă ă Ą ą Ć ć Ĉ ĉ Ċ ċ Č č Ď ď Đ đ Ē ē Ĕ ĕ Ė ė Ę ę Ě ě Ĝ ĝ Ğ ğ Ġ ġ Ģ ģ Ĥ ĥ Ħ ħ Ĩ ĩ Ī ī Ĭ ĭ Į į İ ı Ĳ ĳ Ĵ ĵ Ķ ķ ĸ Ĺ ĺ Ļ ļ Ľ ľ Ŀ ŀ Ł ł Ń ń
Ņ ņ Ň ň ŉ Ŋ ŋ Ō ō Ŏ ŏ Ő ő Œ œ Ŕ ŕ Ŗ ŗ Ř ř Ś ś Ŝ ŝ Ş ş Š š Ţ ţ Ť ť Ŧ ŧ Ũ ũ Ū ū Ŭ ŭ Ů ů Ű ű Ų ų Ŵ ŵ Ŷ ŷ Ÿ Ź ź Ż ż Ž ž ſ

# Latin Extended-B [ſ-ɏ]
ƀ Ɓ Ƃ ƃ Ƅ ƅ Ɔ Ƈ ƈ Ɖ Ɗ Ƌ ƌ ƍ Ǝ Ə Ɛ Ƒ ƒ Ɠ Ɣ ƕ Ɩ Ɨ Ƙ ƙ ƚ ƛ Ɯ Ɲ ƞ Ɵ Ơ ơ Ƣ ƣ Ƥ ƥ Ʀ Ƨ ƨ Ʃ ƪ ƫ Ƭ ƭ Ʈ Ư ư Ʊ Ʋ Ƴ ƴ Ƶ ƶ Ʒ Ƹ ƹ ƺ ƻ Ƽ ƽ ƾ ƿ ǀ ǁ ǂ ǃ Ǆ
ǅ ǆ Ǉ ǈ ǉ Ǌ ǋ ǌ Ǎ ǎ Ǐ ǐ Ǒ ǒ Ǔ ǔ Ǖ ǖ Ǘ ǘ Ǚ ǚ Ǜ ǜ ǝ Ǟ ǟ Ǡ ǡ Ǣ ǣ Ǥ ǥ Ǧ ǧ Ǩ ǩ Ǫ ǫ Ǭ ǭ Ǯ ǯ ǰ Ǳ ǲ ǳ Ǵ ǵ Ƕ Ƿ Ǹ ǹ Ǻ ǻ Ǽ ǽ Ǿ ǿ Ȁ ȁ Ȃ ȃ Ȅ ȅ Ȇ ȇ Ȉ ȉ
Ȋ ȋ Ȍ ȍ Ȏ ȏ Ȑ ȑ Ȓ ȓ Ȕ ȕ Ȗ ȗ Ș ș Ț ț Ȝ ȝ Ȟ ȟ Ƞ ȡ Ȣ ȣ Ȥ ȥ Ȧ ȧ Ȩ ȩ Ȫ ȫ Ȭ ȭ Ȯ ȯ Ȱ ȱ Ȳ ȳ ȴ ȵ ȶ ȷ ȸ ȹ Ⱥ Ȼ ȼ Ƚ Ⱦ ȿ ɀ Ɂ ɂ Ƀ Ʉ Ʌ Ɇ ɇ Ɉ ɉ Ɋ ɋ Ɍ ɍ Ɏ ɏ

# Latin Extended Additional [Ḁ-Ḵ]
Ḁ ḁ Ḃ ḃ Ḅ ḅ Ḇ ḇ Ḉ ḉ Ḋ ḋ Ḍ ḍ Ḏ ḏ Ḑ ḑ Ḓ ḓ Ḕ ḕ Ḗ ḗ Ḙ ḙ Ḛ ḛ Ḝ ḝ Ḟ ḟ Ḡ ḡ Ḣ ḣ Ḥ ḥ Ḧ ḧ Ḩ ḩ Ḫ ḫ Ḭ ḭ Ḯ ḯ Ḱ ḱ Ḳ ḳ Ḵ

# Character class for all: [0-9a-zA-ZµºÀ-ÖØ-áãäæ-öøú-ɏḀ-Ḵ]
)

# FUNCTION: letters_to_numbers {{{
# Converts each character of input string into number 0..61
#
letters_to_numbers() {
    local letters="$1" l

    reply=( )

    if [[ "$letters" != [0-9a-zA-ZµºÀ-ÖØ-áãäæ-öøú-ɏḀ-Ḵ]## ]]; then
        print "Incorrect character detected in: '$letters'. Gcode should consist only from a-z, A-Z, 0-9 characters, plus 450 unicode characters [µºÀ-ÖØ-áãäæ-öøú-ɏḀ-Ḵ]"
        return 1
    fi

    integer number
    for l in "${(@s::)letters}"; do
        number="${characters[(i)$l]}"
        number=number-1
        reply+=( "$number" )
    done

    return 0
}
# }}}
# FUNCTION: numbers_to_letters {{{
# Converts array of numbers into string [0-9a-zA-Z<unicode chars>]+
numbers_to_letters() {
    REPLY=""
    integer i
    for i in "$@"; do
        if [[ "$i" -lt 0 || "$i" -gt 511 ]]; then
            print "Incorrect number during character conversion: $i"
            return 1
        fi
        REPLY+="${characters[i+1]}"
    done

    return 0
}
# }}}
# FUNCTION: decode_gcode {{{
# Turns gcode into bits
decode_gcode() {
    local letters="$1"

    local -a bits
    local workingvar="$letters"
    while [ "${workingvar//0/}" != "" ]; do
        div2 "$workingvar"
        workingvar="${reply[1]}"
        bits=( "${reply[2]}" "${bits[@]}" )
        # print "After div $workingvar/${reply[2]}"
    done
    # print "Bits of the letters $letters are: ${(j::)bits[@]}"
    reply=( "${bits[@]}" )
}
# }}}
# FUNCTION: get_integer_from_base_256 {{{
# Converts given base-256 string into integer
# Warning: it tagets integer (signed), so
# the size of number is limited here (while
# decode_gcode generates series of bits of
# arbitrary length)
get_integer_from_base_256() {
    local letters="$1"
    local -a bits
    local workingvar="$letters"

    # Get base-2 generated array consisting of 1 and 0
    while [ "${workingvar//0/}" != "" ]; do
        div2 "$workingvar"
        workingvar="${reply[1]}"
        bits=( "${reply[2]}" "${bits[@]}" )
    done

    # Now sum up the obtained 0 and 1
    integer i mul=1 size="${#bits}"
    REPLY="0"
    for (( i=size; i>=1; i-- )); do
        REPLY=$(( REPLY + bits[i]*mul ))
        mul=$(( mul * 2 ))
    done

    # TODO: detect overflow and other problems
    return 0
}
# }}}
# FUNCTION: encode_gcode_str01 {{{
# Takes string of 0 and 1 and encodes it to base-256
# number expressed via 0-9a-zA-Z<Unicode chars>
#
encode_gcode_str01() {
    str_01_to_24-bit_pack_numbers "$1"
    encode_gcode_24-bit_pack_numbers "${reply[@]}"

}
# }}}
# FUNCTION: encode_gcode_arr01 {{{
# Takes array (positional parameters) of 0 and 1 and encodes
# it to base-256 number expressed via 0-9a-zA-Z<Unicode chars>
#
encode_gcode_arr01() {
    arr_01_to_24-bit_pack_numbers "$@"
    encode_gcode_24-bit_pack_numbers "${reply[@]}"
}
# }}}
# FUNCTION: encode_gcode_24-bit_pack_numbers {{{
# Takes 24-bit pack numbers and encodes them to base-256
# number expressed via 0-9a-zA-Z<Unicode chars>
#
encode_gcode_24-bit_pack_numbers() {
    numbers=( "$@" )

    local -a nums_base256 workingvar
    workingvar=( "${numbers[@]}" )

    integer all_zero=1 i
    for i in "${workingvar[@]}"; do
        if [[ "$i" -ne 0 ]]; then
            all_zero=0
            break
        fi
    done

    while (( all_zero != 1 )); do
        div_24-bit_pack_numbers_256 "${workingvar[@]}"
        workingvar=( "${reply[@]}" )
        nums_base256=( "$REPLY" "${nums_base256[@]}" )

        # Check if workingvar is all zero
        all_zero=1
        for i in "${workingvar[@]}"; do
            if [[ "$i" -ne 0 ]]; then
                all_zero=0
                break
            fi
        done
    done

    # print "Base256 numbers of $str01 are: ${(j:,:)nums_base256[@]}"
    numbers_to_letters "${nums_base256[@]}" # Result in $REPLY
    reply=( "${nums_base256[@]}" )          # Additional result
}
# }}}
# FUNCTION: div2 {{{
# $1 - gcode's letters
# $reply - ( "gcode's letters after division" "remainder 0 or 1" )
div2() {

    #
    # First translate the letters to numbers and put them into array
    #

    local letters="$1"
    local -a numbers
    letters_to_numbers "$letters" || return 1
    numbers=( "${reply[@]}" )

    #
    # Now operate on the array performing long-division
    #

    local -a result
    result=()

    integer prepared_for_division="${numbers[1]}" input
    for input in ${(@)numbers[2,-1]} 0; do
        integer quotient=prepared_for_division/2

        result+=( "$quotient" )

        integer recovered=$(( quotient*2 ))
        integer subtracted=prepared_for_division-recovered

        prepared_for_division=256*subtracted+input
    done

    #
    # Now convert the result to letters
    #

    numbers_to_letters "${result[@]}" || return 2

    #
    # Return
    #

    reply=( "$REPLY" "$subtracted" )

    return 0
}
# }}}
# FUNCTION: str_01_to_24-bit_pack_numbers {{{
# Takes STRING of 0 and 1 and converts it to array of numbers
# that are 24-bit packs taken from right to left, from the string
#
str_01_to_24-bit_pack_numbers() {
    local -a bits
    bits=( "${(@s::)1}" )
    arr_01_to_24-bit_pack_numbers "${bits[@]}"

    return 0
}
# }}}
# FUNCTION: arr_01_to_24-bit_pack_numbers {{{
# Takes ARRAY (@) of 0 and 1 and converts it to array of numbers
# that are 24-bit packs taken from right to left, from the string
#
arr_01_to_24-bit_pack_numbers() {
    local -a bits pack numbers
    bits=( "$@" )
    integer count=0 i size="${#bits}"

    # Take packs of 8 bits, convert each to number and store in array
    for (( i=size; i>=1; i-- )); do
        pack=( "$bits[i]" "${pack[@]}" )
        count+=1
        (( count < 24 && i != 1 )) && continue
        count=0

        # Convert the max. 8 bit pack to number
        integer result=0 p
        for p in "${pack[@]}"; do
            result=result*2+p
        done

        numbers=( "$result" "${numbers[@]}" )
        pack=( )
    done

    reply=( "${numbers[@]}" )
    return 0
}
# }}}
# FUNCTION: div_24-bit_pack_numbers_256 {{{
# $1 - series of 0 and 1
# $reply - ( "series of 0 and 1, result of division" "remainder 0 ... 61" )
div_24-bit_pack_numbers_256() {
    local -a numbers
    numbers=( "$@" )

    # print "Dividing numbers: " "${numbers[@]}"

    #
    # Now operate on the array performing long-division
    #

    integer cur last
    cur=1
    last="${#numbers}"

    local -a result
    result=()

    integer prepared_for_division="${numbers[cur]}"
    while (( 1 )); do
        integer quotient=prepared_for_division/256

        result+=( "$quotient" )

        integer recovered=$(( quotient*256 ))
        integer subtracted=prepared_for_division-recovered

        cur+=1
        if (( cur > last )); then
            break
        fi

        prepared_for_division=16777216*subtracted+${numbers[cur]}
    done

    # print "Result of division: " "${result[@]}"
    # print "Remainder: $subtracted"

    #
    # Return
    #

    reply=( "${result[@]}" )
    REPLY="$subtracted"

    return 0
}
# }}}
# FUNCTION: convert_integer_to_base_256 {{{
# Takes number in $1, returns [0-9a-zA-Z<unicode chars>]+
# - representation of the number in base-256
#
convert_integer_to_base_256() {
    integer number="$1"
    local -a digits

    integer new_number=number
    integer remainder
    while (( new_number != 0 )); do
        remainder=new_number%256
        new_number=new_number/256

        digits+=( "$remainder" )
    done

    [[ "${#digits}" -eq 0 ]] && digits+=( 0 )
    [[ "${#digits}" -eq 1 ]] && digits+=( 0 )
    [[ "${#digits}" -eq 2 ]] && digits+=( 0 )

    digits=( "${(Oa)digits[@]}" )

    numbers_to_letters "${digits[@]}"
}
# }}}

# vim:ft=zsh
